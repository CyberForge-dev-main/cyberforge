from flask import Flask, jsonify, request
from flask_cors import CORS
from flask_jwt_extended import JWTManager, jwt_required
from config import Config
from models import db, User, Challenge, Submission
from auth import register_user, authenticate_user, get_current_user

from time import time

RATE_LIMIT_WINDOW = 60
RATE_LIMIT_MAX = 5
_rate_buckets = {}

def is_rate_limited(user_id: int, challenge_id: int) -> bool:
    """Rate limit per user per challenge"""
    key = f"{user_id}:{challenge_id}"
    now = time()
    bucket = _rate_buckets.get(key, [])
    bucket = [t for t in bucket if now - t < RATE_LIMIT_WINDOW]
    
    if len(bucket) >= RATE_LIMIT_MAX:
        _rate_buckets[key] = bucket
        return True
    
    bucket.append(now)
    _rate_buckets[key] = bucket
    return False

app = Flask(__name__)
app.config.from_object(Config)

db.init_app(app)
jwt = JWTManager(app)
CORS(app, origins=["*"], supports_credentials=True)

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'OK', 'message': 'Backend is running'}), 200

@app.route('/api/register', methods=['POST'])
def register():
    data = request.get_json()
    if not data or not data.get('username') or not data.get('password'):
        return jsonify({'error': 'Missing required fields'}), 400
    username = data['username']
    email = data.get('email', f"{username}@example.local")
    password = data['password']
    user, error = register_user(username=username, email=email, password=password)
    if error:
        return jsonify({'error': error}), 400
    return jsonify({
        'message': 'User registered successfully',
        'user': {'id': user.id, 'username': user.username, 'email': user.email}
    }), 201

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    if not data or not data.get('username') or not data.get('password'):
        return jsonify({'error': 'Missing credentials'}), 400
    user, token = authenticate_user(data['username'], data['password'])
    if not user:
        return jsonify({'error': token}), 401
    return jsonify({
        'message': 'Login successful',
        'access_token': token,
        'user': {'id': user.id, 'username': user.username}
    }), 200

@app.route('/api/submit_flag', methods=['POST'])
@jwt_required()
def submit_flag():
    user = get_current_user()
    data = request.get_json()
    
    if not data or not data.get('challenge_id') or not data.get('flag'):
        return jsonify({'error': 'Missing fields'}), 400
    
    challenge_id = data['challenge_id']
    challenge = Challenge.query.get(challenge_id)
    if not challenge:
        return jsonify({'error': 'Challenge not found'}), 404
    
    # 1. FIRST: Check if already solved
    existing = Submission.query.filter_by(
        user_id=user.id,
        challenge_id=challenge_id,
        is_correct=True
    ).first()
    
    if existing:
        return jsonify({
            'error': 'Challenge already solved',
            'solve_time': existing.solve_time,
            'points': 0
        }), 400
    
    # 2. SECOND: Rate limit per challenge
    if is_rate_limited(user.id, challenge_id):
        return jsonify({
            'success': False,
            'message': 'Too many attempts. Please try again later.'
        }), 429
    
    # 3. THIRD: Validate flag
    is_correct = (data['flag'] == challenge.flag)
    
    # Calculate solve time (seconds since registration)
    solve_time = None
    if is_correct:
        from datetime import datetime
        time_diff = datetime.utcnow() - user.created_at
        solve_time = int(time_diff.total_seconds())
    
    submission = Submission(
        user_id=user.id,
        challenge_id=challenge.id,
        submitted_flag=data['flag'],
        is_correct=is_correct,
        solve_time=solve_time
    )
    
    db.session.add(submission)
    db.session.commit()
    
    return jsonify({
        'success': is_correct,
        'message': 'Correct flag!' if is_correct else 'Wrong flag',
        'points': challenge.points if is_correct else 0,
        'solve_time': solve_time
    }), 200

@app.route('/api/challenges', methods=['GET'])
def get_challenges():
    challenges = Challenge.query.all()
    return jsonify([{
        'id': c.id, 'name': c.name, 'description': c.description,
        'points': c.points, 'port': c.port, 'category': c.category,
        'difficulty': c.difficulty
    } for c in challenges]), 200

@app.route('/api/leaderboard', methods=['GET'])
@jwt_required()
def get_leaderboard():
    users = User.query.all()
    result = []
    for user in users:
        correct = Submission.query.filter_by(user_id=user.id, is_correct=True).all()
        points = sum(Challenge.query.get(s.challenge_id).points for s in correct if Challenge.query.get(s.challenge_id))
        result.append({"username": user.username, "solved": len(correct), "points": points})
    return jsonify(sorted(result, key=lambda x: x["points"], reverse=True)), 200

@app.route('/api/user/progress', methods=['GET'])
@jwt_required()
def user_progress():
    user = get_current_user()
    submissions = Submission.query.filter_by(user_id=user.id, is_correct=True).all()
    solved_ids = [s.challenge_id for s in submissions]
    return jsonify({
        'username': user.username,
        'challenges_solved': len(submissions),
        'total_points': sum(s.challenge.points for s in submissions),
        'solved_ids': solved_ids
    }), 200

@app.route('/api/user/<username>/profile', methods=['GET'])
def get_user_profile(username):
    """Get detailed user profile with statistics"""
    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    correct_submissions = Submission.query.filter_by(
        user_id=user.id,
        is_correct=True
    ).all()
    
    total_points = sum(s.challenge.points for s in correct_submissions)
    
    by_category = {}
    for submission in correct_submissions:
        category = submission.challenge.category
        if category not in by_category:
            by_category[category] = {'solved': 0, 'points': 0}
        by_category[category]['solved'] += 1
        by_category[category]['points'] += submission.challenge.points
    
    favorite_category = None
    if by_category:
        favorite_category = max(by_category.items(), key=lambda x: x[1]['solved'])[0]
    
    users = User.query.all()
    leaderboard = []
    for u in users:
        correct = Submission.query.filter_by(user_id=u.id, is_correct=True).all()
        points = sum(Challenge.query.get(s.challenge_id).points for s in correct if Challenge.query.get(s.challenge_id))
        leaderboard.append({'username': u.username, 'points': points})
    leaderboard = sorted(leaderboard, key=lambda x: x['points'], reverse=True)
    rank = next((i+1 for i, u in enumerate(leaderboard) if u['username'] == username), None)
    
    recent = Submission.query.filter_by(
        user_id=user.id,
        is_correct=True
    ).order_by(Submission.submitted_at.desc()).limit(5).all()
    
    recent_activity = [
        {
            'challenge_name': s.challenge.name,
            'challenge_id': s.challenge_id,
            'points': s.challenge.points,
            'submitted_at': s.submitted_at.isoformat(),
            'solve_time': s.solve_time
        }
        for s in recent
    ]
    
    solve_times = [s.solve_time for s in correct_submissions if s.solve_time is not None]
    avg_solve_time = int(sum(solve_times) / len(solve_times)) if solve_times else None
    
    return jsonify({
        'username': user.username,
        'email': user.email,
        'joined': user.created_at.isoformat(),
        'stats': {
            'total_points': total_points,
            'challenges_solved': len(correct_submissions),
            'rank': rank,
            'total_users': len(users),
            'favorite_category': favorite_category,
            'by_category': by_category,
            'avg_solve_time': avg_solve_time,
            'recent_activity': recent_activity
        }
    }), 200

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

def init_db():
    with app.app_context():
        db.create_all()
        if Challenge.query.count() == 0:
            challenges = [
                Challenge(name='SSH Basics', description='Find the flag in the home directory', 
                         flag='flag{welcome_to_cyberforge_1}', points=100, port=2222,
                         category='SSH', difficulty='Easy'),
                Challenge(name='Hidden Files', description='Find the hidden flag file', 
                         flag='flag{linux_basics_are_fun}', points=100, port=2223,
                         category='SSH', difficulty='Easy'),
                Challenge(name='Directory Search', description='Search directories for the flag', 
                         flag='flag{find_and_conquer}', points=100, port=2224,
                         category='SSH', difficulty='Medium'),
                Challenge(name='Juice Shop: Admin Access', description='Login as admin in Juice Shop. Submit admin email as flag format: flag{admin_email}', 
                         flag='flag{admin@juice-sh.op}', points=150, port=3001,
                         category='Web', difficulty='Easy'),
                Challenge(name='Juice Shop: SQL Injection', description='Bypass login using SQL injection in Juice Shop', 
                         flag='flag{sqli_success}', points=200, port=3001,
                         category='Web', difficulty='Medium'),
                Challenge(name='Juice Shop: XSS', description='Execute XSS attack in Juice Shop', 
                         flag='flag{xss_executed}', points=200, port=3001,
                         category='Web', difficulty='Medium'),
            ]
            for challenge in challenges:
                db.session.add(challenge)
            db.session.commit()

if __name__ == '__main__':
    init_db()
    app.run(debug=False, host='0.0.0.0', port=5000)


# ============================================================
# CHALLENGE POOL ENDPOINTS
# ============================================================

@app.route("/api/challenge/assign/<int:challenge_id>", methods=["POST"])
@jwt_required()
def assign_challenge(challenge_id):
    from pool_manager import pool_manager
    user_id = get_jwt_identity()
    challenge = Challenge.query.get(challenge_id)
    if not challenge:
        return jsonify({"error": "Challenge not found"}), 404
    instance = pool_manager.assign_container(user_id, challenge_id, db.session)
    if not instance:
        return jsonify({"error": "No available containers"}), 503
    return jsonify({
        "success": True,
        "instance": {
            "id": instance.id,
            "container_name": instance.container_name,
            "port": instance.assigned_port,
            "ssh_command": f"ssh ctfuser@localhost -p {instance.assigned_port}"
        }
    }), 201

@app.route("/api/challenge/release/<int:instance_id>", methods=["POST"])
@jwt_required()
def release_challenge(instance_id):
    from pool_manager import pool_manager
    from models import ChallengeInstance
    user_id = get_jwt_identity()
    instance = ChallengeInstance.query.get(instance_id)
    if not instance:
        return jsonify({"error": "Instance not found"}), 404
    if instance.user_id != user_id:
        return jsonify({"error": "Not your instance"}), 403
    success = pool_manager.release_container(instance_id, db.session)
    return jsonify({"success": success}), 200 if success else 500

@app.route("/api/challenge/my-instances", methods=["GET"])
@jwt_required()
def get_my_instances():
    from models import ChallengeInstance
    user_id = get_jwt_identity()
    instances = ChallengeInstance.query.filter_by(user_id=user_id, status="active").all()
    return jsonify({
        "instances": [{
            "id": i.id,
            "challenge_id": i.challenge_id,
            "container_name": i.container_name,
            "port": i.assigned_port,
            "ssh_command": f"ssh ctfuser@localhost -p {i.assigned_port}"
        } for i in instances]
    }), 200
